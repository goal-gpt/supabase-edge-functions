create extension if not exists "moddatetime" with schema "extensions";

create extension if not exists "vector" with schema "extensions";


create table "public"."chat" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."chat" enable row level security;

create table "public"."chat_line" (
    "id" bigint generated by default as identity not null,
    "chat" integer,
    "message" text,
    "sender" text,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."chat_line" enable row level security;

create table "public"."content" (
    "id" bigint generated by default as identity not null,
    "link" text not null,
    "source" text,
    "title" text,
    "media_type" text,
    "raw_content" text,
    "shareable" boolean,
    "user_id" uuid,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."content" enable row level security;

create table "public"."document" (
    "id" bigint generated by default as identity not null,
    "content" integer not null,
    "embedding" vector,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "raw_content" text not null,
    "start_line" integer,
    "end_line" integer
);


alter table "public"."document" enable row level security;

create table "public"."plan" (
    "id" bigint generated by default as identity not null,
    "user_id" uuid,
    "title" text,
    "status" text,
    "steps" json,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."plan" enable row level security;

create table "public"."profile" (
    "id" uuid not null,
    "username" text,
    "first_name" text,
    "last_name" text,
    "avatar_url" text,
    "email" text,
    "background" json,
    "inserted_at" timestamp with time zone not null default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone not null default timezone('utc'::text, now())
);


alter table "public"."profile" enable row level security;

CREATE UNIQUE INDEX chat_line_pkey ON public.chat_line USING btree (id);

CREATE UNIQUE INDEX chat_pkey ON public.chat USING btree (id);

CREATE UNIQUE INDEX content_link_key ON public.content USING btree (link);

CREATE UNIQUE INDEX content_pkey ON public.content USING btree (id);

CREATE UNIQUE INDEX document_pkey ON public.document USING btree (id);

CREATE UNIQUE INDEX plan_pkey ON public.plan USING btree (id);

CREATE UNIQUE INDEX profile_pkey ON public.profile USING btree (id);

alter table "public"."chat" add constraint "chat_pkey" PRIMARY KEY using index "chat_pkey";

alter table "public"."chat_line" add constraint "chat_line_pkey" PRIMARY KEY using index "chat_line_pkey";

alter table "public"."content" add constraint "content_pkey" PRIMARY KEY using index "content_pkey";

alter table "public"."document" add constraint "document_pkey" PRIMARY KEY using index "document_pkey";

alter table "public"."plan" add constraint "plan_pkey" PRIMARY KEY using index "plan_pkey";

alter table "public"."profile" add constraint "profile_pkey" PRIMARY KEY using index "profile_pkey";

alter table "public"."chat" add constraint "chat_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."chat" validate constraint "chat_user_id_fkey";

alter table "public"."chat_line" add constraint "chat_line_chat_fkey" FOREIGN KEY (chat) REFERENCES chat(id) ON DELETE CASCADE not valid;

alter table "public"."chat_line" validate constraint "chat_line_chat_fkey";

alter table "public"."content" add constraint "content_link_key" UNIQUE using index "content_link_key";

alter table "public"."content" add constraint "content_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."content" validate constraint "content_user_id_fkey";

alter table "public"."document" add constraint "document_content_fkey" FOREIGN KEY (content) REFERENCES content(id) ON DELETE CASCADE not valid;

alter table "public"."document" validate constraint "document_content_fkey";

alter table "public"."plan" add constraint "plan_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."plan" validate constraint "plan_user_id_fkey";

alter table "public"."profile" add constraint "profile_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."profile" validate constraint "profile_id_fkey";

alter table "public"."profile" add constraint "username_length" CHECK ((char_length(username) >= 3)) not valid;

alter table "public"."profile" validate constraint "username_length";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profile (id, first_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'first_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.match_documents(query_embedding vector, match_threshold double precision, match_count integer)
 RETURNS TABLE(id bigint, content integer, raw_content text, similarity double precision, link text, title text)
 LANGUAGE sql
 STABLE
AS $function$
  select
    document.id,
    document.content,
    document.raw_content,
    1 - (document.embedding <=> query_embedding) as similarity,
    content.link,
    content.title
  from document
  join content on document.content = content.id
  where 1 - (document.embedding <=> query_embedding) > match_threshold
    and content.shareable is true
  order by similarity desc
  limit match_count;
$function$
;

CREATE OR REPLACE FUNCTION public.update_chat_timestamp()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
   UPDATE public.chat SET updated_at = timezone('utc'::text, now())
   WHERE id = NEW.chat;
   RETURN NEW;
END;
$function$
;

create policy "Users can delete their own chats."
on "public"."chat"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can insert their own chats."
on "public"."chat"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their own chats."
on "public"."chat"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can view their own chats."
on "public"."chat"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can delete chat lines from their own chats."
on "public"."chat_line"
as permissive
for delete
to public
using ((auth.uid() = ( SELECT chat.user_id
   FROM chat
  WHERE (chat.id = chat_line.chat))));


create policy "Users can insert chat lines to their own chats."
on "public"."chat_line"
as permissive
for insert
to public
with check ((auth.uid() = ( SELECT chat.user_id
   FROM chat
  WHERE (chat.id = chat_line.chat))));


create policy "Users can select chat lines of their own chats."
on "public"."chat_line"
as permissive
for select
to public
using ((auth.uid() = ( SELECT chat.user_id
   FROM chat
  WHERE (chat.id = chat_line.chat))));


create policy "Users can update chat lines of their own chats."
on "public"."chat_line"
as permissive
for update
to public
using ((auth.uid() = ( SELECT chat.user_id
   FROM chat
  WHERE (chat.id = chat_line.chat))));


create policy "Enable read access for all users"
on "public"."content"
as permissive
for select
to public
using (true);


create policy "Users can delete their own content."
on "public"."content"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can insert their own content."
on "public"."content"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their own content."
on "public"."content"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can view shareable content or their own content."
on "public"."content"
as permissive
for select
to public
using (((shareable = true) OR (auth.uid() = user_id)));


create policy "Users can view a document if they can view the corresponding co"
on "public"."document"
as permissive
for select
to public
using (( SELECT ((auth.uid() = content.user_id) OR (content.shareable = true))
   FROM content
  WHERE (content.id = document.content)));


create policy "Users can delete their own plans."
on "public"."plan"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Users can insert their own plans."
on "public"."plan"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Users can update their own plans."
on "public"."plan"
as permissive
for update
to public
using ((auth.uid() = user_id));


create policy "Users can view their own plans."
on "public"."plan"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can delete their own profile."
on "public"."profile"
as permissive
for delete
to public
using ((auth.uid() = id));


create policy "Users can insert their own profile."
on "public"."profile"
as permissive
for insert
to public
with check ((auth.uid() = id));


create policy "Users can update their own profile."
on "public"."profile"
as permissive
for update
to public
using ((auth.uid() = id));


create policy "Users can view their own profile."
on "public"."profile"
as permissive
for select
to public
using ((auth.uid() = id));


CREATE TRIGGER update_chat_after_insert_chat_line AFTER INSERT ON public.chat_line FOR EACH ROW EXECUTE FUNCTION update_chat_timestamp();

CREATE TRIGGER handle_updated_at BEFORE UPDATE ON public.profile FOR EACH ROW EXECUTE FUNCTION moddatetime('updated_at');


